# 第四章 陷阱与系统调用
* 4.1 RISC-V 陷阱
    * 以下的控制寄存器用于内核通知CPU如何处理陷阱时使用。
        * **stvec** 存储陷阱处理函数的地址，当发生需要处理陷阱时从stvec中读取。
        * **sepc** 当陷阱发生时，RISC-V保存调入陷阱之前的程序计数器的寄存器。当sret（从陷阱处理函数返回到用户程序时）将sepc的写入到程序计数器PC中。
        * **scause** RISC-V 引起掉入陷阱的原因的数字保存在该寄存器中
        * **sstatus** 在sstatus中的SIE比特位控制devide intterups（设备中断）是否有效。如果内核晴空SIE，则RISC-V将推迟设备中断，直到内核设置SIE，SPP比特位表名陷阱时来自用户模式还是监管者模式，sret指令用该寄存器来返回相应的模式。

    *  当发生陷阱时（除了计时器中断）RISC-V执行以下操作
        * 如果是设备中断，切sstatus的SIE比特位是清空的，则不做任何处理
        * 通过清空SIE比特位，无效设备中断。
        * 复制pc的值到sepc
        * 保存当前的模式到sstatus的SPP位中
        * 设定scause
        * 转换到监管者模式
        * 复制stvec到pc中
        * 执行新的PC
    
    * 在调入陷阱时CPU不会切换到内核的页表。理由是实现安全方面的隔离

* 4.2来自用户空间的陷阱
    * RISC-V中硬件不会切换页表，因此在用户空间的页表中存在stvec（陷阱处理函数的程序计数器）的值。
    * 回想用户空间内存的空间布局，在用户空间内存的最高的位附近（TRAMPOLINE）保存了陷阱处理函数。
        * 在XV6中stvec寄存器指向该区域。
        * 内核内存页表与用户内存页表都有TRAMPOLIENE的映射，且虚拟内存的值相同。
        * 在uservec指向的用户陷阱处理函数中保存了32个通用集村的值到陷阱栈桢中。
            * 陷阱栈桢在用户空间内存的TRAMPOLINE的低一个页的位置中。（TRAPFRAME）
        * trapframe（进程的属性）保存着当前进程的内核栈的空间地址，需要将sp（栈顶地址寄存器）舍只为kernel-stack的值
    * 在用户陷阱处理函数中需要处理三种情况
        * 系统调用，
        * 设备中断
        * 异常
        
    * 详细细节参考4.2节
        * [4.2节细节](http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/c4/s2.html)

* 4.3 调用system call 代码
    * 系统调用会讲调用系统函数的番号写入到a7寄存器中，并调用ecall指令。
    * ecall指令会将模式调换到监视者模式，并且调用stvec中指向的陷阱处理函数

* 4.4 系统调用参数：代码
    * 内核函数argint argaddr argfd 通过指定参数的位置与指针，获取用户调用时传递的参数
    * fetchstr函数可以获取用户空间传递的字符传
    * 内核对物理内存时直接映射的，因此可以通过walk寻找到用户空间传递的虚拟内存的物理地址，并可以对其直接修改。

* 4.5 来自内核的陷阱
    * 当运行在内核时stvec指向的是kernelvec
    * kernelvec保存32个通用寄存器的值到内核栈中。并跳转到kerneltrap中。
    * 内核陷阱处理函数中处理两种情况
        * 设备中断
        * 异常。
    