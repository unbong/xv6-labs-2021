# syscall 实验笔记
## System call tracing
* 完成trace的功能，需要能够指定mask参数，指定要跟踪的指令
    * 该课程体系下在用户模式调用系统函数的过程如下
        * 在user.h  中追加trace函数的声明
        * 在usys.pl 中追加调用内核模式下执行的sys_trace的函数，在这个pl中生成生成调用sys_trace汇编代码，使得用户模式下调用的trace，会在该汇编中得到执行，并通过ecall 函数来调用内核函数
        * ecall指令会执行kerner的syscall函数，并通过process的结构体获得该进程下的信息（传递的参数等）
        * syscall 根据a7寄存器值（进程结构体中有保存） 来调用相应的内核函数。
        * 追加一个sys_trace的函数取得的mask后，写入到process结构体的变量的trace_mask（新追加）中使得能够在其他系统调用中也能够得到该值。
        * 在fork的实现的上下文拷贝的部分中，需要追加一个process结构题的trace_mask复制的处理
    
    * 要点
        * 系统通过进程，虚拟内存等实现，完成了进程与内存的隔离。
        * 在该题的实现中需要通过process来保持上下文。

# lab page table 实验笔记
* syscall 加速
  * 在特定的虚拟内存地址与物理内存之间形成映射关系。
  * 然后在每次访问时从特定的虚拟地址地址处取得值。
        * 在xv6的内核模式下，satp因为已经覆盖位内核的页表，并且内核模式下物理地址与虚拟地址是直接映射的关系，因此不需要通过walk处理就能够对内存进行修改。

* print vm page
    * 通过递归页表的层级树打印出PTE_V为有效的内存地址

* 检测页是否已经被访问
    * 使用PTE_A（1<<6)的位来对0级的pte进行检测。
    * 因为一旦被访问过PTE_A位就会永久有效
    * 
